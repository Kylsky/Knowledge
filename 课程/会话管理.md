# 会话管理

## session & cookie & token

通常服务器与客户端保持状态通信会通过在Header中加上User-Agent信息，其中保存了浏览器信息，操作系统信息等做标识。但是由于这些信息不能作为用户的唯一识别，因此无法做到真正的状态管理。

因此为了解决这个方法，用户第一次登陆服务器时，后者会记录一个sessionId，并在向客户返回响应时回传该id，名曰cookie，于是用户在后续的访问中只需要在请求头的Cookie标签中传递这个唯一的标识即可。

token与cookie原理相似，但不用必须存储在请求头中，另外，由于httpsession只能存在于单机中，无法实现集群化部署，因此适用范围比较受限，而token作为一个字符串，可以在集群中共享。



## 浏览器同源策略与跨域

若当前浏览器的网页地址和服务端地址不同源，浏览器则会出于保护客户端为目的拒绝客户端进行ajax请求，跨域问题即表示违反浏览器同源策略所引发的问题

通常解决方法有**jsonp**(https://blog.csdn.net/badmoonc/article/details/82289252，通过script标签发起get请求获取服务端响应，并在本地进行回调获取结果，以解决跨域问题，但是只支持get方法)和**cors**(可以直接发送ajax，实现方式是在请求头加上指定的信息)



## CSRF & XSS攻击安全与防御

### XSS

1.在网站的html中通过嵌入违规代码从而实现发起外站请求，从而进行站点攻击(如流量攻击)

2.在富文本编辑器中嵌入可执行程序进行站点攻击

### CSRF

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；

​    2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；

​    3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；

​    4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；


    5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。