## 1.Mysql执行流程

![image-20210518105518581](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210518105518581.png)



## 2.Mysql启动命令

### --skip-networking

禁止客户端使用TCP/IP网络进行通信



### --default-storage-engine=MyISAM

设置默认存储引擎

```
注意，写成--default-storage-engine = MyISAM，像这样携带了空白字符是不允许的
```



### -h || --host

设置主机名



### -u || --user

设置用户名



### -p || --password

设置密码



### -P || --Port

设置端口，默认3306



### -V || --version

版本信息



### --dafaults-file

该命令可以组织mysql到默认的路径下搜索配置文件



### --defaults-extra-file

添加额外的配置文件路径



## 3.Mysql配置文件

### 配日志文件路径

windows:

![image-20210518161401811](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210518161401811.png)



类unix：

![image-20210518161534550](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210518161534550.png)



### 配置文件内容

![image-20210518161935928](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210518161935928.png)

举例如下：

```
[server]
option1
option2 = value2

以上操作等同于mysqld --option1 --option2=value2
```

另外，如果选项组名称与程序名称一致，则选项下的参数将专门用于该程序，如[mysql]和[mysqld]。还有两个选项组比较特别：[server]、[client]，这两个组下边的启动选项将作用于所有的服务端或客户端程序。

![image-20210518163057406](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210518163057406.png)



### 配置文件优先级

如果在多个配置文件中设置了相同的启动选项，会以最后一个配置文件中的为准。

另外，如果出现了如下的情况：

```
[server] 
default-storage-engine=InnoDB

[mysqld]
default-storage-engine=MyISAM
```

那么，将以最后一个出现的组中的启动选项为准



## 4.Mysql系统变量

### 查看系统变量

show variables [like 匹配的模式];

```
show variables like 'default_storage_engine';
show variables like 'max_connections';
```



### 设置系统变量

1.通过命令行设置

mysqld --default-storage-engine=MyISAM --max-connections=10



2.通过配置文件设置

```
[server] 
default-storage-engine=MyISAM
max-connections=10
```



### 不同作用范围的系统变量

作用范围分为2种：

1.GLOBAL

全局变量，影响服务器的整体操作

2.SESSION（LOCAL）

会话变量，影响某个客户端连接的操作

![image-20210519102816542](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210519102816542.png)

通过以下命令可以查看不同作用范围的系统变量

```
show [GLOBAL | SESSION] variables [like 匹配的模式]
```



## 5.字符集和比较规则

![image-20210519111834766](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210519111834766.png)



### 字符集查看

show (character set | charset) [like 匹配的模式]



### 比较规则查看

show collation [like 匹配的模式]



### 比较规则

| 后缀 | 英文释义           | 描述             |
| ---- | ------------------ | ---------------- |
| _ai  | accent insensitive | 不区分重音       |
| _ci  | case insensitive   | 不区分大小写     |
| _cs  | case sensitive     | 区分大小写       |
| _bin | binary             | 以二进制方式比较 |



### 比较规则和字符集的级别

mysql有4个级别的字符集和比较规则

* 服务器级别

| 系统变量             | 描述                 |
| -------------------- | -------------------- |
| character_set_server | 服务器级别的字符集   |
| collation_server     | 服务器级别的比较规则 |

* 数据库级别

| 系统变量               | 描述                 |
| ---------------------- | -------------------- |
| character_set_database | 数据库级别的字符集   |
| collation_database     | 数据库级别的比较规则 |

* 表级别
* 列级别

![image-20210520094911245](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210520094911245.png)



## 6.InnoDB

### 行格式

可以在创建或修改表的时候指定行格式

```
create table 表名 ROW_FORMAT=行格式名称
```

InnoDB存在四种行格式：

* Compact
* Redundant
* Dynamic
* Compressed



### 示例：Compact行格式

compact行格式的组成如下：

#### **1.变长字段长度列表**

compact格式的每一条行记录的格式都如下：

![image-20210520110203234](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210520110203234.png)

在Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序**逆序存放**。

InnoDB 有它的一套规则，我们首先声明一下W 、M 和L 的意思：
1. 假设某个字符集中表示一个字符最多需要使用的字节数为W ，也就是使用SHOW CHARSET 语句的结果中的
Maxlen 列，比方说utf8 字符集中的W 就是3 ， gbk 字符集中的W 就是2 ， ascii 字符集中的W 就是
1 。
2. 对于变长类型VARCHAR(M) 来说，这种类型表示能存储最多M 个字符（注意是字符不是字节），所以这个类
型能表示的字符串最多占用的字节数就是M×W 。
3. 假设它实际存储的字符串占用的字节数是L 。

![image-20210520110231919](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210520110231919.png)

另外需要注意的一点是，变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的 。



#### **2.NULL值列表**

首先，统计表中允许存储的null列有哪些，如果表中没有null列，则null值列表也不存在。，否则将每个允许存储NULL 的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：二进制位的值为1 时，代表该列的值为NULL，二进制位的值为0 时，代表该列的值不为NULL。

MySQL 规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0 。



#### **3.记录头信息**

![image-20210520111421420](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210520111421420.png)



#### **4.记录的真实数据**

mysql会为每个记录默认的添加一些列，也称为隐藏列

| 列名                      | 是否必须 | 占用空间 | 描述     |
| ------------------------- | -------- | -------- | -------- |
| row_id(DB_ROW_ID)         | 否       | 6字节    | 行id     |
| transaction_id(DB_TRX_ID) | 是       | 6字节    | 事务id   |
| roll_pointer(DB_ROLL_PTR) | 是       | 7字节    | 回滚指针 |

优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique 键作为主键，如果表中连Unique 键都没有定义的话，则InnoDB 会为表默认添加一个名为row_id 的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 transaction_id和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）



### 示例：Dynamic行格式

mysql版本5.7使用的默认行格式是dynamic，他存储数据的方式和compact差不多，不过在处理行溢出数据的时候，不会像compact一样将记录的前768字节数据存储在当前页中，而是将记录的所有数据存储在溢出的页中



### 行溢出数据

#### VARCHAR(M)

varchar最多能存储65535个字节的数据，除了本身的数据之外，还包括一些其他的数据（storage head），如下：

```
1.真实数据
2.真实数据占用字节的长度（最多使用2个字节来存储）
3.null值标识，如果该列有not null属性则可以没有这部分存贮空间
```

对于ascii字符集（一个字符对应一个字节）来说，则最多可以存储65533个字节，对于其他字符集如utf8等，能存储的就会更少。



#### 数据溢出

已知一个页的大小是16kb，也就是16384字节，对于一个varchar的最大值65533个字节来说，就会出现一个页放不下一条记录的状况。

在Compact 和Reduntant 行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，如图所示：

![image-20210603111839570](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210603111839570.png)



#### 行溢出的临界点

MySQL 中规定一个页中至少存放两行记录。每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要136 个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。

每个记录需要的额外信息是27 字节。这27个字节包括下边这些部分：

```
2个字节用于存储真实数据的长度
1个字节用于存储列是否是NULL值
5个字节大小的头信息
6个字节的row_id 列
6个字节的transaction_id 列
7个字节的roll_pointer 列
```

假设一个列中存储的数据字节数为n，那么发生行溢出现象时需要满足这个式子：
136 + 2×(27 + n) > 16384
求解这个式子得出的解是： n > 8098 。也就是说如果一个列中存储的数据不大于8098 个字节，那就不会发生行溢出，否则就会发生行溢出。不过这个8098 个字节的结论只是针对只有一个列的varchar_size_demo 表来说的，如果表中有多个列，那上边的式子和结论都需要改一改了，所以重点就是：你不用关注这个临界点是什么，只要知道如果我们想一个行中存储了很大的数据时，可能发生行溢出的现象。



## 7.InnoDB数据页结构

官方称这种存放记录的页为索引（ INDEX ）页，鉴于我们还没有了解过索引是个什么东西，而这些表中的记录就是我们日常口中所称的数据，所以目前还是叫这种存放记录的页为数据页吧。

![image-20210528085656248](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210528085656248.png)

![image-20210528085754638](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210528085754638.png)



### 记录在页结构的存储

在页的7个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records 部分。但是在一开始生成页的时候，其实并没有User Records 这个部分，每当我们插入一条记录，都会从Free Space 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records 部分，当Free Space 部分的空间全部被User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：

![image-20210528085954402](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210528085954402.png)



### 记录的头信息

举compact行格式为例，一条记录中除了真实数据，还包含变长字段长度列表、NULL值列表、记录头信息，记录的一些关键信息会存储在记录头中，记录头包含5个字节，大致示意图如下：

![image-20210607090138068](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210607090138068.png)



| 字段名       | 意义                                                         |
| ------------ | ------------------------------------------------------------ |
| delete_type  | 删除的标志位，1为删除                                        |
| min_rec_mask | B+树的每层非叶子节点中的最小记录都会添加该标记。             |
| n_owned      | 页分组中的最大记录的持有节点数                               |
| heap_no      | 标记当前记录在本页中的位置                                   |
| record_type  | 一共有4种类型的记录， 0 表示普通记录， 1 表示B+树非叶节点记录， 2 表示最小记录， 3 表示最大记录 |
| next_record  | 示从当前记录的真实数据到下一条记录的真实数据的地址偏移量     |



### 页头部信息PageHeader

记录的头部信息储存和记录与记录之间的一些关联关系，此时将思维上升到页的层面，页为了知道如本页中已经存储了多少条记录，或者第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了1个叫pageHeader的部分，这个部分**固定占用56字节**，专门存储各种状态信息（针对数据页来说）。

![image-20210607091509407](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210607091509407.png)



### 文件头部FileHeader

上边唠叨的Page Header 是专门针对数据页记录的各种状态信息，比方说页里头有多少个记录，有多少个槽。我们现在描述的File Header 针对各种类型的页都通用，也就是说不同类型的页都会以File Header 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、
下一个页是谁啦吧啦吧啦～ 这个部分占用**固定的38 个字节**，是由下边这些内容组成：

![image-20210607093637437](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210607093637437.png)



#### FIL_PAGE_TYPE

| 类型名称                | 十六进制 | 描述                   |
| ----------------------- | -------- | ---------------------- |
| FIL_PAGE_TYPE_ALLOCATED | 0x0000   | 最新分配，还没使用     |
| FIL_PAGE_UNDO_LOG       | 0x0002   | undo日志               |
| FIL_PAGE_INODE          | 0x0003   | 段信息节点             |
| FIL_PAGEIBUF_FREE_LIST  | 0x0004   | insert buffer 空闲列表 |
| FIL_PAGE_IBUF_BITMAP    | 0x0005   | insert buffer 位图     |
| FIL_PAGE_TYPE_SYS       | 0x0006   | 系统页                 |
| FIL_PAGE_TRX_SYS        | 0x0007   | 事务系统数据           |
| FIL_PAGE_TYPE_FSP_HDR   | 0x0008   | 表空间头部信息         |
| FIL_PAGE_TYPE_XDES      | 0x0009   | 扩展描述页             |
| FIL_PAGE_TYPE_BLOB      | 0x000A   | blob页                 |
| FIL_PAGE_INDEX          | 0x45BF   | 索引页                 |



## 8.B+树

![image-20210607101936936](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210607101936936.png)

这里来回顾下record_type：

0.用户记录

1.目录项记录

2.最小记录

3.最大记录



需要注意的是，目录项记录中只存储了主键id和页号



### 聚簇索引

B+ 树本身就是一个目录，或者说本身就是一个索引。它有两个特点：

1.使用记录主键值的大小进行记录和页的排序，包括三个方面的含义:

* 页内的记录是按照主键的大小顺序排成一个单向链表。
* 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
* 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成
  一个双向链表。

2.B+树的叶子节点存储的是完整的用户记录



我们把具有这两种特性的B+ 树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL 语句中显式的使用INDEX 语句去创建（后边会介绍索引相关的语句），InnoDB 存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在InnoDB 存储引擎中， 聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的**索引即数据，数据即索引**。



### 二级索引

上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+ 树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该咋办呢？难道只能从头到尾沿着链表依次遍历记录么？不，我们可以多建几棵B+ 树，不同的B+ 树中的数据采用不同的排序规则。比方说我们用c2 列的大小作为数据页、页中记录的排序规则，再建一棵B+ 树，效果如下图所示：

![image-20210607104711679](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210607104711679.png)

这个B+ 树与上边介绍的聚簇索引有几处不同：

1.使用记录c2 列的大小进行记录和页的排序，这包括三个方面的含义：

* 页内的记录是按照c2 列的大小顺序排成一个单向链表。
* 各个存放用户记录的页也是根据页中记录的c2 列大小顺序排成一个双向链表。
* 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2 列大小顺序排
  成一个双向链表。

2.B+ 树的叶子节点存储的并不是完整的用户记录，而只是**c2列+主键**这两个列的值。
3.目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配。



根据上面的分析可以得出一个结论——在这里如果想根据非主键列值查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程也被成为**回表**



### 联合索引

联合索引本质上也是一个二级索引，比方说我们想让B+ 树按照c2和c3 列的大小进行排序，这个包含两层含义：

* 先把各个记录和页按照c2 列进行排序。
* 在记录的c2 列相同的情况下，采用c3 列进行排序

![image-20210607105642024](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210607105642024.png)

如图所示，我们需要注意一下几点：

* 每条目录项记录都由c2 、c3 、页号这三个部分组成，各条记录先按照c2 列的值进行排序，如果记录的c2 列相同，则按照c3 列的值进行排序。
* B+ 树叶子节点处的用户记录由c2 、c3 和主键c1 列组成。



## 9.B+树索引注意事项

### 根页面万年不动

B+ 树的形成过程是这样的：

* 每当为某个表创建一个B+ 树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+ 树索引对应的根节点中既没有用户记录，也没有目录项记录。
* 随后向表中插入用户记录时，先把用户记录存储到这个根节点中。
* 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a 中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b 。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a 或者页b 中，而根节点便升级为存储目录项记录的页。

这个过程需要特别注意的是：**一个B+树索引的根节点自诞生之日起，便不会再移动。**这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB 存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。



### 二级索引目录项记录的唯一性

如果二级索引中目录项记录的内容只是索引列 + 页号的搭配的话，那么为c2 列建立索引后的B+ 树应该长这
样：

![image-20210607111457096](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210607111457096.png)

为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：

* 索引列的值
* 主键值
* 页号

所以实际示意图应该是这样的:

![image-20210607111616832](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210607111616832.png)



### 索引的代价

在熟悉了B+ 树索引原理之后，本篇文章的主题是唠叨如何更好的使用索引，虽然索引是个好东西，可不能乱建，在介绍如何更好的使用索引之前先要了解一下使用这玩意儿的代价，它在空间和时间上都会拖后腿：

* 空间上的代价
  这个是显而易见的，每建立一个索引都要为它建立一棵B+ 树，每一棵B+ 树的每一个节点都是一个数据页，一个页默认会占用16KB 的存储空间，一棵很大的B+ 树由许多数据页组成，那可是很大的一片存储空间呢。
* 时间上的代价
  每次对表中的数据进行增、删、改操作时，都需要去修改各个B+ 树索引。而且我们讲过， B+ 树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+ 树都要进行相关的维护操作。



### B+树索引适用的条件

#### 1.全值匹配

这个没啥好说的，另外，使用select时将字段调换顺序也是没关系的，mysql的查询优化器会帮我们处理



#### 2.最左匹配

搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下边的查询语句：

```
SELECT * FROM person_info WHERE name = 'Ashburn';
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';
# 搜索条件中必须出现左边的列才可以使用到这个B+ 树索引，因此下面这条不行
SELECT * FROM person_info WHERE birthday = '1990-09-27';
```



#### 3.匹配列前缀

对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的，比方说我们想查询名字以'As' 开头的记录，那就可以这么写查询语句：

```
SELECT * FROM person_info WHERE name LIKE 'As%';
```

但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：

```
SELECT * FROM person_info WHERE name LIKE '%As%';
```

MySQL 就无法快速定位记录位置了，因为字符串中间有'As' 的字符串并没有排好序，所以只能全表扫描了。



#### 4.匹配范围值

```
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

B+ 树中的数据页和记录是先按name 列排序的，所以我们上边的查询过程其实是这样的：

* 找到name 值为Asa 的记录。
* 找到name 值为Barlow 的记录。
* 由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记
  录都可以很容易的取出来
* 找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。



不过在使用联合进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，**只有对索引最左边的那个**
**列进行范围查找的时候才能用到B+ 树索引**，比方说这样：

```
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-0
1';
```

上边这个查询可以分成两个部分：
1. 通过条件name > 'Asa' AND name < 'Barlow' 来对name 进行范围，查找的结果可能有多条name 值不同的
记录，
2. 对这些name 值不同的记录继续通过birthday > '1980-01-01' 条件继续过滤。



#### 5.精确匹配某一列并范围匹配另外一列

对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精
确查找，则右边的列可以进行范围查找，比方说这样：

```
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday
< '2000-12-31'
```

这个查询的条件可以分为3个部分：
1. name = 'Ashburn' ，对name 列进行精确查找，当然可以使用B+ 树索引了。
2. birthday > '1980-01-01' AND birthday < '2000-12-31' ，由于name 列是精确查找，所以通过name =
'Ashburn' 条件查找后得到的结果的name 值都是相同的，它们会再按照birthday 的值进行排序。所以此时
对birthday 列进行范围查找是可以用到B+ 树索引的。
3. phone_number > '15100000000' ，通过birthday 的范围查找的记录的birthday 的值可能不同，所以这个
条件无法再利用B+ 树索引了，只能遍历上一步查询得到的记录。



#### 6.用于排序

我们在写查询语句的时候经常需要对查询出来的记录通过ORDER BY 子句按照某种规则进行排序。一般情况下，
我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序、吧啦吧啦排序等等在内存中对
这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的
空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在MySQL 中，把这种在内存中或者磁
盘上进行排序的方式统称为文件排序（英文名： filesort ），跟文件这个词儿一沾边儿，就显得这些排序操作
非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。但是如果ORDER BY 子句里使用到了我们的
索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：

```
SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
```

注意事项：

##### * 联合索引

对于联合索引有个问题需要注意， ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出，



##### * asc、desc

不可以使用索引进行排序的几种情况：asc、desc混用



##### * WHERE子句中出现非排序使用到的索引列

如果WHERE子句中出现了非排序使用到的索引列，那么排序依然是使用不到索引的，比方说这样：

country并非索引列，因此这个查询只能先把符合搜索条件country = 'China' 的记录提取出来后再进行排序，是使用不到索引对的

```
SELECT * FROM person_info WHERE country = 'China' ORDER BY name LIMIT 10;
```



##### * 排序列包含非同一个索引的列

有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，比方说：

```
SELECT * FROM person_info ORDER BY name, country LIMIT 10;
```



##### * 排序列使用了复杂的表达式

要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式，比方说这样：

```
SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;
```



#### 7.用于分组

有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询：

```
SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number
```

这个查询语句相当于做了**3次分组操作**：

* 先把记录按照name 值进行分组，所有name 值相同的记录划分为一组。

* 将每个name 值相同的分组里的记录再按照birthday 的值进行分组，将birthday 值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。

* 再将上一步中产生的小分组按照phone_number 的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把大分组分成若干个小分组，然后把若干个小分组再细分成更多的小小分组。

然后针对那些小小分组进行统计，比如在我们这个查询语句中就是统计每个小小分组包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的B+ 树中的索引列的顺序是一致的，而我们的B+ 树索引又是按照索引列排好序的，这不正好么，所以可以直接使用B+ 树索引进行分组。和使用B+ 树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组，吧啦吧啦的～





### 回表的代价

举以下查询作为例子：

```
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

在使用name索引对应的B+树进行查询时大致可以分为以下2个步骤：

1.从name索引中查询出对应的用户记录

2.由于查询的是全部字段，因此需要回表，这时需要把索引查询出的记录的id作为主键到聚簇索引中找到完整的用户记录，即回表。

由于name索引对应的B+ 树中的记录首先会按照name 列的值进行排序，所以值在Asa ～ Barlow 之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为顺序I/O 。根据第1步中获取到的记录的id 字段的值可能并不相连，而在聚簇索引中记录是根据id （也就是主键）的顺序排列的，所以根据这些并不连续的id值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为随机I/O 。一般情况下，顺序I/O比随机I/O的性能高很多，所以步骤1的执行可能很快，而步骤2就慢一些。所以这个使用name索引的查询有这么两个特点：

* 会使用到两个B+ 树索引，一个二级索引，一个聚簇索引。
* 访问二级索引使用顺序I/O ，访问聚簇索引使用随机I/O 。

```
那什么时候采用全表扫描的方式，什么时候使用采用二级索引 + 回表的方式去执行查询呢？这个就是传说中的查询优化器做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用二级索引 + 回表的方式。当然优化器做的分析工作不仅仅是这么简单，但是大致上是个这个过程。一般情况下，限制查询获取较少的记录数会让优化器更倾向于选择使用二级索引 + 回表的方式进行查询，因为回表的记录越少，性能提升就越高，比方说上边的查询可以改写成这样：

SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' LIMIT 10;

添加了LIMIT 10 的查询更容易让优化器采用二级索引 + 回表的方式进行查询。对于有排序需求的查询，上边讨论的采用全表扫描还是二级索引 + 回表的方式进行查询的条件也是成立的，比方说下边这个查询：

SELECT * FROM person_info ORDER BY name, birthday, phone_number;

由于查询列表是* ，所以如果使用二级索引进行排序的话，需要把排序完的二级索引记录全部进行回表操作，这样操作的成本还不如直接遍历聚簇索引然后再进行文件排序（ filesort ）低，所以优化器会倾向于使用全表扫描的方式执行查询。如果我们加了LIMIT 子句，比如这样：

SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;

这样需要回表的记录特别少，优化器就会倾向于使用二级索引 + 回表的方式执行查询。
```



### 覆盖索引

为了彻底告别回表操作带来的性能损耗，我们建议：最好在查询列表里**只包含索引列**，比如这样：

```
SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow'
```



## 10.数据目录

### 数据目录

数据目录可以通过下面的sql进行查询

```
SHOW VARIABLES LIKE 'datadir';
```



### 系统表空间

默认情况下， InnoDB 会在数据目录下创建一个名为**ibdata1**、大小为12M 的文件，这个文件就是对应的系统表空
间在文件系统上的表示。这个文件是自扩展文件，当不够用的时候它会自己增加文件大小



### 数据库信息

MySQL的数据目录对应了一个系统变量datadir

```
show variables like 'datadir';
|Variable_name	|    Value		 |
|datadir		|/var/lib/mysql  |
```

每个数据库在目录下都有一个独立的目录，每次创建一个数据库，mysql就会在数据目录下创建一个和数据库名同名的子目录，并在该子目录下创建一个名为**db.opt**的文件，该文件包含了该数据库的各种属性，如字符集和比较规则。



### 表信息

每个表的信息可以分为两种：

* 表结构的定义
* 表中的数据

为了保存这些信息， InnoDB 和MyISAM 这两种存储引擎都在数据目录下对应的数据库子目录下创建了一个专门用于描述表结构的文件，文件名是这样：

```
表名.frm
```

表中的数据和索引则使用下面的文件类型来存储：

```
表名.idb
```



## 11.InnoDB表空间

### 页、区、组的概念

innodb中一个页大小默认为16kb，为了更好地管理页，innodb使用区的概念来划分页数据。对于页来说，连续的64个页就是一个区，默认占用1mb空间的大小，不论是系统空间还是独立表空间，都是由若干个区构成的。

同时，每256个区被划分为一组。从数据大小来对这三个概念进行划分则为如下情况：

```
页——16KB
区——1MB（包含64个页）
组——256MB（包含256个区）
```

<img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/image-20210623155659743.png" alt="image-20210623155659743" style="zoom:50%;" />



第一个组最开始的3个页面类型是固定的，也就是extend0区最开始的3个页面的类型是固定的，分别是：

1. FSP_HDR

   用于等级整个表空间的一些整体属性以及本组的所有区。整个表空间只有一个该类型的页

2. IBUF_BITMAP

3. INODE

其余各组最开始的2个页面类型是固定的，分别是：

1. XDES

   全称是extent descriptor，用来等级本组256个区的属性

2. IBUF_BITMAP



### 段的概念

举范围查询为例，其实是对B+ 树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB的设计者对B+ 树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段（ segment ），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。

默认情况下一个使用InnoDB 存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。设计InnoDB 的大叔们都挺节俭的，当然也考虑到了这种情况。这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。现在为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，设计InnoDB 的大叔们提出了一个碎片（fragment）区的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。所以此后为某个段分配存储空间的策略是这样的：在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。
