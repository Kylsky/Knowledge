# 计算机网络(三)——运输层

## 一、概述

运输层位于应用层和网络层之间，是在端系统中而不是在路由器中实现的。在发送端，运输层将从发送应用程序进程接收到的报文换成运输层分组，该分组称为运输层报文段。因特网有两种运输层协议——**TCP**和**UDP**协议。



## 二、多路复用和多路分解

### 多路复用

在源主机从**不同套接字**中收集数据块，并为每个数据块封上首部信息从而生成报文，然后将报文段传递到网络层，所有这些工作称为**多路复用**。多路复用要求：

①套接字有唯一标识符（如源端口号）；

②每个报文段有特殊字段来指示该报文段所要交付到的套接字（如目 的端口号）。

ps:端口号是一个16位的数，大小在0-65535之间，0-1023范围的端口号称为周知端口号，是受限制的。



### 多路分解

将运输层报文中的数据交付到正确的套接字的工作称为多路分解。



## 三、无连接运输：UDP

UDP协议只做了运输层协议能够做的最少工作，除了复用/分解功能以及少量的差错检测外，它几乎没有对IP增加别的东西。



### UDP的特点

1.**关于发送什么数据以及何时发送的应用层控制更为精细。**UDP会将数据立即传递给网络层，而如TCP因为拥有拥塞控制机制，可能导致交付时间延长。

2.**无需建立连接**

3.**无连接状态**

4.**分组首部开销小**。每个TCP报文都有20个字节的首部开销，而UDP仅有8字节的首部开销



### UDP报文结构

![img](http://kylescloud.top/site/pic/udp.png)

UDP首部只有四个字段，每个字段由两个字节组成。**长度**字段表示了UDP报文（首部+数据）的字节长度。**检验和**用于进行比特差错校验。



### UDP检验和

发送方的UDP对报文中的所有16比特字的和（即UDP首部和应用数据）进行反码运算，得到的结果被放在UDP报文段中的**检验和**字段，在接收方中，若16比特字的和加上检验和的二进制结果存在0，则说明分组中出现了差错。



## 四、面向连接的运输：TCP

### TCP报文结构

![img](http://kylescloud.top/site/pic/tcp.png)

#### 源端口号

两个字节，用于存放源端口。

#### 目的端口号

两个字节，用于存放目的端口号。

#### 序号

4字节，被TCP发送方使用。TCP报文段首部**最重要的字段之一**。序号是建立在传送的字节流上的，而不是建立在传送的报文段的序列上的。

**一个报文段的序号是该报文段首字节的字节流编号。**

#### 确认号

4字节，被TCP接收方使用。TCP报文段首部**最重要的字段之一**。

**主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的编号**

#### 首部长度

4比特，指示了以32比特的字为一个单位的TCP首部长度。由于TCP选项字段的原因，TCP首部长度是可变的。（通常选项字段为空，所以TCP首部的典型长度是20字节。

#### 接收窗口

2个字节，用于流量控制。

#### 因特网检验和

2字节，与UDP检验和类似，用来做数据的差错检测

#### 紧急数据指针

2个字节，紧急数据的最后一个字节由紧急数据指针字段指出

#### 选项字段

用于发送方和接收方协商最大报文段长度时使用

#### 数据

用于存放应用层的数据

#### 标志字段

**ACK**

指示**确认**字段中的值是有效的，即该报文段包括一个已被成功接收报文段的确认

**RST**

用于连接的建立和删除。当服务器端口不接受客户连接时，服务端将返回的报文中**RST**标志位置1，用于告诉客户端“当前套接字无法使用”

**SYN**

用于连接的建立

**FIN**

用于连接的删除

**CWR**

用于拥塞控制

**ECE**

用于拥塞控制

**URG**

指示报文段里存在着被发送端的上层实体置为“紧急”的数据

**PSH**

当PSH被置为1时，指示接收方应立刻将数据交给上层



### TCP三次握手

#### 第一步

客户端TCP向服务端TCP发送一个特殊的TCP报文段。该报文不包含应用层数据，但是将**SYN**标志位置为1，并为**序号**字段设置一个随机值(client_isn)

#### **第二步**

SYN报文到达服务器主机，服务器从IP数据报中提取SYN报文段，为TCP连接分配TCP缓存和变量，并向客户TCP发送允许连接的报文段。该报文段首部的**确认号**字段被置为client_isn+1，**SYN**、**ACK**标志位被置为1。**序号**字段被设为随机值(server_isn)，该报文段被称为**SYNACK**报文段

#### 第三步

收到SYNACK后，客户为连接分配缓存和变量。客户主机向服务器发送另外一个报文段，对服务器的允许连接进行了确认。该报文段将**SYN**置0，**ACK**置1，**确认号**设置为server_isn+1。第三次握手阶段可以在报文段负载中携带客户到服务器的数据。



### TCP四次挥手

1.客户端发送报文，将首部标志位**FIN**置1

2.服务端接收报文，发送报文，将首部标志位**ACK**置1

3.服务端发送第二条报文，将首部标志位**FIN**置1

4.客户端收到**FIN**报文，发送报文，将首部标志位**ACK**置1



### 为什么TCP握手是3次？

3次握手可以保证客户端和服务端双方都已经确认建立连接关系。

若连接只进行到到了第二次握手中的ACK报文，而服务端没有收到客户端发送的第三段ACK报文，则服务端将无法确认自己是否已经建立了连接，即无法判断客户端在连接中是否存活，因此可能**导致长时间等待从而浪费资源**或者**因为请求的超时导致脏连接**





### 为什么TCP挥手是4次?

客户端和服务端想要断开连接，则需要2个条件：①双方都通知对方自己要断开连接的消息；②双方都收到对方要断开连接的消息。即一方发出FIN报文并要求对方回复ACK报文，随后准备断开连接，另一方也是如此。只有双方都进入准备断开连接的状态才能断开连接，即必须发送**四段报文**，但是FIN和ACK报文不能像TCP第二次握手中的SYNACK报文一样将SYN和ACK标志位同时置1，因为在一方准备断开连接时，TCP连接中可能还存在数据的传输，若此时另一方收到FIN报文后立即发送报文将FIN和ACK一起发送，并最终断开连接，则传输的数据就会中断。所以需要4次报文传输，即4次挥手



## 五、TCP拥塞控制

在最为宽泛的级别上，根据网络层是否为运输层拥塞控制提供显示帮助来区分拥塞控制的方法——**端到端拥塞控制**和**网络辅助的拥塞控制**。因为IP层不向端系统提供显式的网络拥塞反馈，所以TCP必须使用端到端拥塞控制。



### TCP拥塞控制三问

#### ①一个TCP发送方如何限制它向其他连接发送的速率？

#### ②一个TCP发送方如何感知从它到目的地之间的路径上是否存在拥塞？

#### ③当发送方感知到端到端的拥塞时，采用何种算法来改变发送速率？



### TCP拥塞控制算法

TCP拥塞控制算法给出了上述3问的解答。先认识一下cwnd（congestion window，拥塞窗口），表示了一个TCP发送发能向网络发送的最大数据量，若数据从发送方到接收方的往返时间是RTT，则数据传输速率为cwnd/RTT

#### 慢启动

在慢启动时，cwnd的值以一个MSS开始，且每当传输的报文段首次被确认时增加一个MSS。**每个报文段被确认后cwnd都会增加1个MSS，并在之后发送双倍的报文段，即慢启动阶段发送速率呈指数级增长**。

当慢启动状态下发生了**由超时指示的丢包事件**，cwnd重新被置为1个MSS，并记录第二个状态变量的值ssthresh为cwnd/2，并再次进入慢启动状态，这时ssthresh不为空，当cwnd的值等于ssthresh时，进入拥塞避免模式。

当慢启动状态下发生了**冗余ACK事件**，则TCP执行快速重传，并进入**快速恢复**状态



#### 拥塞避免

进入拥塞避免模式时，TCP更谨慎地增加cwnd，每次经过确认一个报文段cwnd增加一个MSS。

当出现**超时指示的丢包事件**时，cwnd被设为1个MSS，ssthresh被设为cnwd/2，重新进入慢启动状态（这里基本与慢启动的情况一致）

当出现**冗余ACK事件**，cwnd=cwnd/2，ssthresh=cwnd，进入快速恢复状态。



#### 快速恢复

快速恢复是TCP推荐的而并非必须的构件。在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的ACK，cwnd的值增加一个MSS，即cwnd=sstresh+ACK个数*MSS，并随后重传丢失的数据包。

如果收到的是DupACK，那么cwnd=cwnd+1，并在允许的条件下发送下一个报文

如果收到的是新的ACK，设置cwnd=ssthresh，进入拥塞避免状态



## 六、TCP和UDP的优缺点

### TCP

**TCP的优点：** 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。

**TCP的缺点：** 慢，效率低，占用系统资源高，易被攻击。TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。



### UDP

**UDP的优点：** 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… 

**UDP的缺点：** 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……