# JVM(五)——运行时数据区

## 1.运行时数据区

### 1.1 Program Counter(程序计数器)

程 序 计 数 器（ Program Counter Register） 是 一 块 较 小 的 内 存 空 间， 它 可 以 看 作 是 当 前 线 程 所 执 行 的 字 节 码 的 行 号 指 示 器。

如 果 线 程 正 在 执 行 的 是 一 个 Java 方 法， 这 个 计 数 器 记 录 的 是 正 在 执 行 的 虚 拟 机 字 节 码 指 令 的 地 址； 如 果 正 在 执 行 的 是 本 地（ Native） 方 法， 这 个 计 数 器 值 则 应 为 空（ Undefined）。 此 内 存 区 域 是 唯 一 一 个 在《 Java 虚 拟 机 规 范》 中 没 有 规 定 任 何 OutOfMemoryError 情 况 的 区 域。

**每一个Java虚拟机的线程都有一个独有的程序计数器**，用于存放指令的位置，虚拟机的运行类似于

```
while(notEnd){
	//取pc中位置，找到对应的指令
	//执行指令
	//PC++
}
```



### 1.2 Method Area(方法区)

方 法 区（ Method Area） 与 Java 堆 一 样， 是 各 个 线 程 共 享 的 内 存 区 域， 它 用 于 存 储 已 被 虚 拟 机 加 载 的 类 型 信 息、 常 量、 静 态 变 量、 即 时 编 译 器 编 译 后 的 代 码 缓 存 等 数 据。 虽 然《 Java 虚 拟 机 规 范》 中 把 方 法 区 描 述 为 堆 的 一 个 逻 辑 部 分， 但 是 它 却 有 一 个 别 名 叫 作“ 非 堆”（ Non-Heap）， 目 的 是 与 Java 堆 区 分 开 来。

方法区是一种规范，**在1.8之前**的实现称为永久代(Perm Space)，FGC不会清理Perm Space。**在1.8之后**的实现称为Meta Space(元空间)，会触发FGC。在 JDK 6 的 时 候 HotSpot 开 发 团 队 就 有 放 弃 永 久 代， 逐 步 改 为 采 用 本 地 内 存（ Native Memory） 来 实 现 方 法 区 的 计 划 了 ，到 了 JDK 7 的 HotSpot， 已 经 把 原 本 放 在 永 久 代 的 字 符 串 常 量 池、 静 态 变 量 等 移 出， 而 到 了 JDK 8， 终 于 完 全 废 弃 了 永 久 代 的 概 念， 改 用 与 JRockit、 J9 一 样 在 本 地 内 存 中 实 现 的 元 空 间（ Meta-space） 来 代 替， 把 JDK 7 中 永 久 代 还 剩 余 的 内 容（ 主 要 是 类 型 信 息） 全 部 移 到 元 空 间 中。

方 法 区  的 内 存 回 收 目 标 主 要 是 针 对 **常 量 池** 的 回 收 和 对 **类 型 的 卸 载**， 一 般 来 说 这 个 区 域 的 回 收 效 果 比 较 难 令 人 满 意， 尤 其 是 类 型 的 卸 载， 条 件 相 当 苛 刻， 但 是 这 部 分 区 域 的 回 收 有 时 又 确 实 是 必 要 的。

**运 行 时 常 量 池**（ Runtime Constant Pool） 是 方 法 区 的 一 部 分。 Class 文 件 中 除 了 有 类 的 版 本、 字 段、 方 法、 接 口 等 描 述 信 息 外， 还 有 一 项 信 息 是 常 量 池 表（ Constant Pool Table）， 用 于 存 放 编 译 期 生 成 的 各 种 字 面 量 与 符 号 引 用， 这 部 分 内 容 将 在 类 加 载 后 存 放 到 方 法 区 的 运 行 时 常 量 池 中。

Java 虚 拟 机 对 于 Class 文 件 每 一 部 分（ 自 然 也 包 括 常 量 池） 的 格 式 都 有 严 格 规 定， 如 每 一 个 字 节 用 于 存 储 哪 种 数 据 都 必 须 符 合 规 范 上 的 要 求 才 会 被 虚 拟 机 认 可、 加 载 和 执 行， 但 对 于 运 行 时 常 量 池，《 Java 虚 拟 机 规 范》 并 没 有 做 任 何 细 节 的 要 求， 不 同 提 供 商 实 现 的 虚 拟 机 可 以 按 照 自 己 的 需 要 来 实 现 这 个 内 存 区 域， 不 过 一 般 来 说， 除 了 保 存 Class 文 件 中 描 述 的 符 号 引 用 外， 还 会 把 由 符 号 引 用 翻 译 出 来 的 直 接 引 用 也 存 储 在 运 行 时 常 量 池 中。 

运 行 时 常 量 池 相 对 于 Class 文 件 常 量 池 的 另 外 一 个 重 要 特 征 是 具 备 动 态 性， Java 语 言 并 不 要 求 常 量 一 定 只 有 编 译 期 才 能 产 生， 也 就 是 说， 并 非 预 置 入 Class 文 件 中 常 量 池 的 内 容 才 能 进 入 方 法 区 运 行 时 常 量 池， 运 行 期 间 也 可 以 将 新 的 常 量 放 入 池 中， 这 种 特 性 被 开 发 人 员 利 用 得 比 较 多 的 便 是 String 类 的 intern() 方 法。



### 1.3 HEAP(堆)

堆。所有线程共享一个堆，堆存放了java对象。此内存区域的唯一目的就是存放对象实例，不过随着逃 逸 分 析 技 术 的 日 渐 强 大， **栈 上 分 配**、 **标 量 替 换** 等优 化 手 段 已 经 导 致 一 些 微 妙 的 变 化 悄 然 发 生， 所 以 说 Java 对 象 实 例 都 分 配 在 堆 上 也 渐 渐 变 得 不 是 那 么 绝 对 了。

从 回 收 内 存 的 角 度 看， 由 于 现 代 垃 圾 收 集 器 大 部 分 都 是 基 于 分 代 收 集 理 论 设 计 的， 所 以 Java 堆 中 经 常 会 出 现“ 新 生 代”“ 老 年 代”“ 永 久 代”“ Eden 空 间”“ From Survivor 空 间”“ To Survivor 空 间” 等 名 词， 这 些 概 念 在 后 续 章 节 中 还 会 反 复 登 场 亮 相， 在 这 里 先 说 明 的 是 这 些 区 域 划 分 仅 仅 是 一 部 分 垃 圾 收 集 器 的 共 同 特 性 或 者 说 设 计 风 格 而 已， 而 非 某 个 Java 虚 拟 机 具 体 实 现 的 固 有 内 存 布 局， 更 不 是《 Java 虚 拟 机 规 范》 里 对 Java 堆 的 进 一 步 细 致 划 分。

如 果 从 分 配 内 存 的 角 度 看， 所 有 线 程 共 享 的 Java 堆 中 可 以 划 分 出 多 个 线 程 私 有 的 分 配 缓 冲 区（ Thread Local Allocation Buffer， TLAB）， 以 提 升 对 象 分 配 时 的 效 率。 不 过 无 论 从 什 么 角 度， 无 论 如 何 划 分， 都 不 会 改 变 Java 堆 中 存 储 内 容 的 共 性， 无 论 是 哪 个 区 域， 存 储 的 都 只 能 是 对 象 的 实 例， 将 Java 堆 细 分 的 目 的 只 是 为 了 更 好 地 回 收 内 存。

根 据《 Java 虚 拟 机 规 范》 的 规 定， Java 堆 可 以 处 于 物 理 上 不 连 续 的 内 存 空 间 中， 但 在 逻 辑 上 它 应 该 被 视 为 连 续 的， 这 点 就 像 我 们 用 磁 盘 空 间 去 存 储 文 件 一 样， 并 不 要 求 每 个 文 件 都 连 续 存 放。 但 对 于 大 对 象（ 典 型 的 如 数 组 对 象）， 多 数 虚 拟 机 实 现 出 于 实 现 简 单、 存 储 高 效 的 考 虑， 很 可 能 会 要 求 连 续 的 内 存 空 间。



### 1.4 JVM Stacks

Java虚拟机栈。**每一个线程对应一个**虚拟机栈，型： 每 个 方 法 被 执 行 的 时 候， Java 虚 拟 机 都 会 同 步 创 建 一 个 **栈 帧（Stack Frame）** 用 于 存 储 局 部 变 量 表、 操 作 数 栈、 动 态 连 接、 方 法 出 口 等 信 息。

**1.**Local Variable Table，局部变量表。局 部 变 量 表 存 放 了 编 译 期 可 知 的 各 种 Java 虚 拟 机 基 本 数 据 类 型（ boolean、 byte、 char、 short、 int、 float、 long、 double）

**2.**Operated Stack，操作数栈。方法执行中进行算术运算或者是调用其他的方法进行参数传递的时候是通过操作数栈进行的。在概念模型中，两个栈帧是相互独立的。但是大多数虚拟机的实现都会进行优化，令两个栈帧出现一部分重叠。令下面的部分操作数栈与上面的局部变量表重叠在一块，这样在方法调用的时候可以共用一部分数据，无需进行额外的参数复制传递。

**3.**Dynamic Linking，动态链接。在说明什么是动态连接之前先看看方法的大概调用过程,首先在虚拟机运行的时候,运行时常量池会保存大量的符号引用,这些符号引用可以看成是每个方法的间接引用,如果代表栈帧A的方法想调用代表栈帧B的方法,那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数,但是因为符号引用并不是直接指向代表B方法的内存位置,所以在调用之前还必须要将符号引用转换为直接引用,然后通过直接引用才可以访问到真正的方法,这时候就有一点需要注意,如果符号引用是在类加载阶段或者第一次使用的时候转化为直接应用,那么这种转换成为静态解析,如果是在运行期间转换为直接引用,那么这种转换就成为动态连接。

**4.**return address，返回地址



上 面 这 些 数 据 类 型 在 局 部 变 量 表 中 的 存 储 空 间 以 局 部 变 量 槽（ Slot） 来 表 示， 其 中 64 位 长 度 的 long 和 double 类 型 的 数 据 会 占 用 两 个 变 量 槽， 其 余 的 数 据 类 型 只 占 用 一 个。 局 部 变 量 表 所 需 的 内 存 空 间 在 编 译 期 间 完 成 分 配， 当 进 入 一 个 方 法 时， 这 个 方 法 需 要 在 栈 帧 中 分 配 多 大 的 局 部 变 量 空 间 是 完 全 确 定 的， 在 方 法 运 行 期 间 不 会 改 变 局 部 变 量 表 的 大 小。 请 注 意， 这 里 说 的“ 大 小” 是 指 变 量 槽 的 数 量， 虚 拟 机 真 正 使 用 多 大 的 内 存 空 间（ 譬 如 按 照 1 个 变 量 槽 占 用 32 个 比 特、 64 个 比 特， 或 者 更 多） 来 实 现 一 个 变 量 槽， 这 是 完 全 由 具 体 的 虚 拟 机 实 现 自 行 决 定 的 事 情。



### 1.5 Native Method Stack

本地方法栈。**每一个线程对应一个本地方法栈**，本 地 方 法 栈 为 虚 拟 机 使 用 到 的 本 地（ Native） 方 法 服 务。



### 1.6 Direct Memory

直接内存，连接用户态和内核态。在 JDK 1.4 中 新 加 入 了 NIO（ New Input/ Output） 类， 引 入 了 一 种 基 于 通 道（ Channel） 与 缓 冲 区（ Buffer） 的 I/ O 方 式， 它 可 以 使 用 Native 函 数 库 直 接 分 配 堆 外 内 存， 然 后 通 过 一 个 存 储 在 Java 堆 里 面 的 DirectByteBuffer 对 象 作 为 这 块 内 存 的 引 用 进 行 操 作。 这 样 能 在 一 些 场 景 中 显 著 提 高 性 能， 因 为 避 免 了 在 Java 堆 和 Native 堆 中 来 回 复 制 数 据。 显 然， 本 机 直 接 内 存 的 分 配 不 会 受 到 Java 堆 大 小 的 限 制， 但 是， 既 然 是 内 存， 则 肯 定 还 是 会 受 到 本 机 总 内 存（ 包 括 物 理 内 存、 SWAP 分 区 或 者 分 页 文 件） 大 小 以 及 处 理 器 寻 址 空 间 的 限 制， 一 般 服 务 器 管 理 员 配 置 虚 拟 机 参 数 时， 会 根 据 实 际 内 存 去 设 置-Xmx 等 参 数 信 息， 但 经 常 忽 略 掉 直 接 内 存， 使 得 各 个 内 存 区 域 总 和 大 于 物 理 内 存 限 制（ 包 括 物 理 的 和 操 作 系 统 级 的 限 制）， 从 而 导 致 动 态 扩 展 时 出 现 OutOfMemoryError 异 常。



## 2.JVM指令

### bipush

将一个byte值push到栈中，即压栈

### sipush

将一个shortpush到栈中

### iadd

从栈中弹出两个整数值相加，相加的结果放到栈顶

### isub

从栈中弹出两个整数值相减，后弹出的作为被减数，相减的结果放到栈顶

### imul

从栈中弹出2个整数值相乘，相乘的结果放到栈顶

### istore_x

把栈顶的整数值从栈中弹出存放到局部变量表的x位置上

### iload_x

从局部变量表中位置为x的整数值存放到栈顶

### astore_x

把栈顶的引用值从栈中弹出存放到局部变量表的x位置上

### iconst_x

将整数常量x压栈

### if icmpne x

条件判断，若两个整数相比较不相等，则跳转到第x条指令

### aload

从局部变量表中位置为x的引用值存放到栈顶

### iinc x by i

将局部变量表中x的位置的整数值增加i

### new

创建一个对象，赋默认值并压栈

### dup

复制栈顶元素

### pop

弹出栈顶元素

### invokespecial

调用可直接定位的不需要多态的方法，弹出栈顶元素。如构造方法和private方法

### invokevirtual

调用非静态方法的需要多态的方法

### invokeinterface

调用接口的实现类的方法，如：

```
List<String> list = new ArrayList();
list.add("hello world")
```

### invokestatic

调用静态方法

### invokedynamic

jvm最难的指令，1.7之后增加。lambda表达式或者反射或其他动态语言、ASM动态产生的class用到的指令



