# HashMap线程不安全的原因及表现

参考链接：https://www.cnblogs.com/developer_chan/p/10450908.html

https://www.jianshu.com/p/0d130964ea7f

## 一、扩容情况下的死锁或数据丢失

JDK1.8中规避了死锁的问题，但是在1.7中，由于HashMap中的transfer方法使用了头插法，这会导致多线程访问一个HashMap并扩容时，会使节点产生循环引用问题和数据丢失问题



## 二、put时产生的数据覆盖

JDK1.8中对HashMap进行了优化，在发生hash碰撞，不再采用头插法方式，而是直接插入链表尾部，因此不会出现环形链表的情况，但是在多线程的情况下仍然不安全，没有hash碰撞则会直接插入元素。如果线程A和线程B同时进行putVal操作，刚好这两条不同的数据hash值一样，并且该位置数据为null，所以这线程A、B都会进入相关代码中。假设一种情况，线程A进入后还未进行数据插入时挂起，而线程B正常执行，从而正常插入数据，然后线程A获取CPU时间片，此时线程A不用再进行hash判断了，问题出现：线程A会把线程B插入的数据给**覆盖**，发生线程不安全。



## 三、删除键值对问题

当多个线程同时操作同一个数组位置的时候，也都会先取得现在状态下该位置存储的头结点，然后各自去进行计算操作，之后再把结果写会到该数组位置去，其实写回的时候可能其他的线程已经就把这个位置给修改过了，就会覆盖其他线程的修改。