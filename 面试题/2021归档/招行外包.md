1.自我介绍

做的内容，取得的成绩



2.oauth2的一些问题



# 3.Collection接口继承了哪些接口

继承了Iterable接口



为什么不继承Cloneable接口：

Collection表示一个集合，包含了一组对象。如何存储和维护这些对象是由具体实现来决定的。因为集合的具体形式多种多样，例如list允许重复，set则不允许。而克隆（clone）和序列化（serializable）只对于具体的实体，对象有意义，你不能说去把一个接口，抽象类克隆，序列化甚至反序列化。所以具体的collection实现类是否可以克隆，是否可以序列化应该由其自身决定，而不能由其超类强行赋予。
如果collection继承了clone和serializable，那么所有的集合实现都会实现这两个接口，而如果某个实现它不需要被克隆，甚至不允许它序列化（序列化有风险），那么就与collection矛盾了。



4.三种集合的选择（colletion、map等）



# 5.线程安全的集合

Vector

HashTable

CocurrentHashMap

#### CopyOnWriteArrayList

#### CopyOnWriteArraySet



6.怎么理解线程安全



7.你会如何对一个对象加锁



# 8.mybatis多表操作，xml中多表和单表的区别

自定义返回值，resultMap



# 9.@Transactional注解有哪些属性

| 属性                   | 类型                               | 描述                                                |
| ---------------------- | ---------------------------------- | --------------------------------------------------- |
| noRollbackFor          | Class对象数组                      | 必须继承自Throwable	不会导致事务回滚的异常类数组 |
| noRollbackForClassName | 类名数组                           | 必须继承自Throwable	不会导致事务回滚的           |
| value                  | String                             | 可选的限定描述符，指定使用的事务管理器              |
| propagation            | enum: Propagation                  | 可选的事务传播行为设置                              |
| isolation              | enum: Isolation                    | 可选的事务隔离级别设置                              |
| readOnly               | boolean                            | 读写或只读事务，默认读写                            |
| timeout                | int (in seconds granularity)       | 事务超时时间设置                                    |
| rollbackFor            | Class对象数组，必须继承自Throwable | 导致事务回滚的异常类数组                            |
| rollbackForClassName   | 类名数组，必须继承自Throwable      | 导致事务回滚的异常类名字数组                        |



10.怎么处理分布式事务



11.怎么理解事务



12.redis使用场景，用过哪些数据结构



13.redis持久化（aof、rdb）



14.缓存降级

没答出来



15.redis单线程还是多线程？



16.redis单线程性能高效的原因



17.IO多路复用有哪几种模式



18.阻塞和非阻塞的区别



19.遇到困难的问题，如何牵头解决



20.如果项目即将上线但是任务没有及时完成，需要怎么做？